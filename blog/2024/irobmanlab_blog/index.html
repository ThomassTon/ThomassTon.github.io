<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Multi-Robot Pick and Place | Haolei's Pit </title> <meta name="author" content="Haolei Tong"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://thomasston.github.io/blog/2024/irobmanlab_blog/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Multi-Robot Pick and Place",
            "description": "",
            "published": "September 05, 2024",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Haolei's Pit </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Multi-Robot Pick and Place</h1> <p></p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#introduction">Introduction</a> </div> <div> <a href="#background">Background</a> </div> <ul> <li> <a href="#sampling-based-motion-planning">sampling-based motion planning</a> </li> <li> <a href="#optimization-based-motion-planning">optimization-based motion planning</a> </li> <li> <a href="#komo-and-st-rrt">KOMO and ST-RRT*</a> </li> </ul> <div> <a href="#implementation">Implementation</a> </div> </nav> </d-contents> <h2 id="1-introduction">1. Introduction</h2> <p>In certain robotic applications, there are scenarios where a single robotic arm may struggle to perform tasks, such as handling a large object or a flexible item. In such cases, two or more robotic arms need to collaborate in order to accomplish the task efficiently.</p> <p>In this work, we assume the use of two robotic arms working collaboratively to perform motion planning based on the given initial and target positions of the object to be grasped. Additionally, due to limitations of the simulation framework, the grasping is accomplished through a linking mechanism. In the environmental setup, we also assume that the obstacles remain stationary.</p> <hr> <h2 id="2-background">2. Background</h2> <p>Motion planning is the process of determining a feasible path or sequence of movements for a robot (or other agents) to achieve a specific task while avoiding obstacles and respecting constraints like joint limits, collision avoidance, and smoothness of the motion.</p> <p>Motion planning can be broadly categorized into two types: optimization-based methods and sampling-based methods.</p> <h3 id="21-sampling-based-motion-planning">2.1 sampling-based motion planning</h3> <p>sampling-based motion planning constructs feasible paths for a robot by randomly sampling points in the robot’s configuration space (C-space) and connecting these points to form a valid path from the start to the goal, common approaches include RRT, RRT*, and Bi-RRT.</p> <ul> <li> <p><strong>RRT</strong> incrementally builds a tree-like structure that explores the space by randomly sampling points and connecting them to the existing tree. Thereby finding a collision-free path. With a sufficient number of samples, it’s possible to find a path, though it may not necessarily be the optimal one.</p> </li> <li> <p><strong>RRT*</strong> is an optimized version of RRT. After a vertex has been connected to the cheapest neighbor, the neighbors are again examined. Neighbors are checked if being rewired to the newly added vertex will make their cost decrease. If the cost does indeed decrease, the neighbor is rewired to the newly added vertex.</p> </li> <li> <p><strong>(Bi-RRT)</strong> is an enhanced version of the RRT algorithm. Bi-RRT grows two trees simultaneously,i.e., One tree starts from the initial position of the robot, the other tree starts from the goal position.</p> </li> </ul> <h3 id="22-optimization-based-motion-planning">2.2 optimization-based motion planning</h3> <p>Instead of searching for a path first (like in sampling-based methods), the optimization-based motion planning optimizes the motion directly by minimizing or maximizing a specific objective function, such as minimizing travel time, energy, or avoiding obstacles. Common optimization-based methods include KOMO, CHOMP, and STOMP.</p> <ul> <li> <p><strong>KOMO</strong> means k-order markov optimization. KOMO is a way to formulate path optimization problems.[1]</p> </li> <li> <p><strong>CHOMP (Covariant Hamiltonian Optimization for Motion Planning)</strong> is a method for trajectory optimization invariant to reparametrization. CHOMP uses functional gradient techniques to iteratively improve the quality of an initial trajectory, optimizing a functional that trades off between a smoothness and an obstacle avoidance component.[2]</p> </li> <li> <p><strong>STOMP</strong> is a stochastic trajectory optimazation framework. The approach relies on generating nosiy trajectories to explore the space around an initial trajectory, which are then combined to produced an updated trajectory wit lower cost.[3]</p> </li> </ul> <h3 id="23-komo-and-st-rrt">2.3 KOMO and ST-RRT*</h3> <p>In this project, we utilized two motion planning methods: one is the optimization-based KOMO, and the other is the sampling-based ST-RRT*.</p> <h3 id="231-komo">2.3.1 KOMO</h3> <p><strong>k-order Markov Optimization</strong> is a method used in decision-making processes where the current decision depends not just on the immediate previous state (as in a first-order Markov process) but on a sequence of previous states, up to k steps in the past:</p> \[\min_{x_{0:T}} \sum_{t=0}^{T} f_t(x_{t-k:t})^\top f_t(x_{t-k:t}) + \sum_{t,t'} k(t,t') x_t^\top x_{t'}\] \[\text{s.t.} \quad \forall t : g_t(x_{t-k:t}) \leq 0, \quad h_t(x_{t-k:t}) = 0.\] <p>where \(x_{t-k:t} = (x_{t-k},..., x_{t-1}, x_{t})\) are \(k+1\) tuples of consecutive states. And the the term \(k(t,t^{'})\) is an optional kernel measuring the desired correlation between time steps \(t\) and \(t^{'}\), which we explored but in practice hardly used.</p> <p>To compute the inverse kinematics of a robotic arm, we typically need to define the following parameters:</p> \[\begin{aligned} q &amp;\in \mathbb{R}^n &amp;\text{vector of joint angles (robot configuration)} \\ \dot{q} &amp;\in \mathbb{R}^n &amp;\text{vector of joint angular velocities} \\ \phi : q &amp;\mapsto y \in \mathbb{R}^d &amp;\text{feature (or forward kinematic)} \text{e.g. position} \in \mathbb{R}^3 \text{ or vector} \in \mathbb{R}^3 \\ J(q) &amp;= \frac{\partial \phi}{\partial q} \in \mathbb{R}^{d \times n} &amp;\text{Jacobian} \end{aligned}\] <p>To apply KOMO (K-order Markov Optimization) to inverse kinematics with \(k=2\):</p> \[\begin{aligned} J_{\text{pos}} &amp;= \sum_{t=1}^{T} \| \mathbf{y}_t^{\text{desired}} - \mathbf{y}_t(\mathbf{q}_t) \|^2 &amp;\text{Error of the end effector} \\ J_{\text{smooth}} &amp;= \sum_{t=3}^{T} \left( \lambda_1 \| \theta_t - \theta_{t-1} \|^2 + \lambda_2 \| \theta_t - 2\theta_{t-1} + \theta_{t-2} \|^2 \right) &amp;\text{Smoothness Constraint}\\ \end{aligned}\] <p>Specifically:</p> <ul> <li> <p>\(\lambda_{1}\) controls the first-order smoothness (to prevent excessive changes in joint angles between consecutive time steps).</p> </li> <li> <p>\(\lambda_{2}\) controls second-order smoothness (to avoid abrupt changes in acceleration or angular velocity).</p> </li> <li> <p>\(\theta_{t} - 2\theta_{t-1} + \theta_{t-2}\) approximately describes the change in acceleration of the joint angles.</p> </li> </ul> <p>The final total cost function is:</p> \[\begin{aligned} J &amp;= J_{pos} + J_{smooth} + \text{other constraint terms} \end{aligned}\] <p>We need to minimize this objective function \(J\), .i.e,</p> \[\min_{\theta_{t}, \theta_{t-1}, \theta_{t-2}} J\] <h3 id="232-st-rrt">2.3.2 ST-RRT*</h3> <p>ST-RRT* [4]is an advanced motion planning algorithm specifically designed for dynamic environments, where both spatial and temporal dimensions need to be considered. Its primary goal is to find paths that satisfy velocity constraints while minimizing arrival time.</p> <p>Unlike traditional methods that only plan in a configuration space (Q), ST-RRT* adds a time dimension, forming a space-time state space denoted as \(X = Q \times T\), where \(Q\) represents the configuration space and \(T\) represents the time dimension.</p> <p>ST-RRT* builds on the dual-tree RRT-Connect framework but introduces several key modifications to handle unbounded time spaces and optimize arrival time:</p> <ul> <li> <p><strong>Progressive Goal Region Expansion:</strong> ST-RRT* uses a progressive expansion strategy that gradually increases the sampled time range while ensuring sufficient sample density through batch sampling. The initial time range <strong>B.timeRange</strong> and batch size <strong>B.batchSize</strong> are set. As the algorithm progresses, the time range is expanded by a factor (P.rangeFactor) to include a larger time horizon, allowing the planner to explore more of the time dimension.</p> </li> <li> <p><strong>Conditional Sampling:</strong> Only the intersection of start and goal velocity cones is sampled. This greatly improves efficiency by reducing unnecessary exploration of infeasible areas.</p> </li> <li> <p><strong>Simplified Rewiring:</strong> Like RRT<em>, ST-RRT</em> optimizes paths by rewiring nodes in the tree. After extending the tree with a new node x_new, the goal tree is rewired to ensure that the path to the goal minimizes arrival time.</p> </li> </ul> <p>As shown in the figure below, the orange area represents the goal region, and the blue dashed line is an initial estimate of the feasible goal time:</p> <ul> <li>(a) Using the initial batch of samples, no solution was found.</li> <li>(b) The upper bound of the time space (represented by the dashed line) is expanded, allowing more goal nodes to be sampled, and both trees continue to grow.</li> <li>(c) An initial solution is found (shown in orange), and the upper time bound is reduced accordingly.</li> <li>(d) Tree branches that can no longer contribute to an improved solution are pruned (shown with lower opacity), leading to the final solution after convergence.</li> </ul> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/st-rrt-480.webp 480w,/assets/img/st-rrt-800.webp 800w,/assets/img/st-rrt-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/st-rrt.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <hr> <h2 id="3-implementation">3. Implementation</h2> <p>In this section, we will introduce how to achieve dual-arm collaborative object transportation. The process can be divided into three main steps: scene setup, task planning, and motion planning.</p> <h3 id="31-scene-setup">3.1 Scene Setup</h3> <p>Here, we will set the initial position and target location of the object to be grasped, as well as the fixed positions of any obstacles. Additionally, the positions of the two robots need to be defined. Typically, the robots are placed at a slightly greater distance from each other to prevent collisions while grasping the same object.</p> <p>In this case, the first three elements of Q represent the displacement coordinates along the x, y, and z axes, while the last four elements represent the rotation angles using quaternions. Additionally, setting <code class="language-plaintext highlighter-rouge">contact</code> to 1 enables collision detection.</p> <pre><code class="language-PHP">_obstacle (bin1){ type:ssBox, size:[0.2 0.2 0.1 .01], contact:1 Q:&lt;[ -0, 0, 0.5, 1, 0, .0, 0]&gt; color:[0.9, 0.9, 0.9, 1]}

goal1 (bin1){ joint:rigid type:ssBox, size:[0.1 0.1 0.1 .01], contact:0 Q:&lt;[  0, 0.0, 0.13, 1., 0., .0, 0]&gt; color:[0.4, 1, 1, 0.2]}
goal2 (bin1){ joint:rigid type:ssBox, size:[0.1 0.1 0.1 .01], contact:0 Q:&lt;[  0, 0.0, 0.23, 1., 0., .0, 0]&gt; color:[0.4, 1, 1, 0.2]}

obj2 (bin2){ joint:rigid type:ssBox, size:[0.1 0.1 0.1 .01], contact:1 Q:&lt;[  -0., -0.15, 0.03, 1, 0, .0, 0]&gt; color:[0.4, 1, 1, 1]}
obj1 (bin2){ joint:rigid type:ssBox, size:[0.1 0.1 0.1 .01], contact:1 Q:&lt;[  -0., -0.01, 0.03, 1, 0, .0, 0]&gt; color:[0.4, 1, 1, 1]}
</code></pre> <h3 id="32-task-planning">3.2 Task Planning</h3> <p>Task planning refers to the process of determining the sequence of high-level actions or tasks that a robot (or a group of robots) must perform to achieve a specific goal.</p> <p>Common methods for Task Sequence Planning include Greedy Search, Random Search, and Simulated Annealing Search. <strong>Greedy search</strong> is a locally optimal strategy that, at each step, selects the best immediate option without considering future consequences. <strong>Random search</strong> generates task sequences randomly, evaluates their performance, and selects the best-performing sequence. It does not rely on selecting the best option at each step, instead exploring different combinations of task sequences randomly. <strong>Simulated annealing</strong> is inspired by the physical process of annealing in metallurgy, the algorithm initially allows the acceptance of worse solutions (higher “temperature”) to escape local optima. As the search progresses, the “temperature” is gradually lowered, and the algorithm becomes more likely to accept only better solutions, converging toward a global optimum.</p> <p>However, in our work, there is no need for complex task planning. Instead, we directly use the sequence of objects as the task sequence. Here, a task represents the movement of a robotic arm from position A to position B. For example, moving the arm from the initial position to the position where it can grasp an object constitutes a task. The content of the task is determined by the joint configurations that correspond to the target positions of the robot’s end effector. For example, if two objects need to be transported, this results in four tasks.</p> <h3 id="33-motion-planning">3.3 Motion Planning</h3> <p>In this project, we use the <strong>KOMO</strong> optimizer to solve the inverse kinematics:</p> <p>We can configure the optimizer using the skeleton framework: {1., 1., SY_touch, {pen_tip_0, obj}}: <strong>‘1.’</strong> represents the timestep, <strong>‘SY_touch’</strong> indicates contact with the target, can be replaced with other types of constraints, such as <strong>SY_stable</strong>, which indicates being stationary relative to the target, <strong>‘pen_tip’</strong> represents the robot’s end-effector, <strong>‘obj’</strong> represents the target.</p> <p>Additionally, we can use <strong>addObjective</strong> to add extra constraints, such as ensuring the distance between the end-effector and the object is zero, or enforcing that the end-effector remains perpendicular to the object’s surface.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">Skeleton</span> <span class="n">S</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">SY_touch</span><span class="p">,</span> <span class="p">{</span><span class="n">pen_tip_0</span><span class="p">,</span> <span class="n">obj</span><span class="p">}},</span>
    <span class="p">{</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">SY_touch</span><span class="p">,</span> <span class="p">{</span><span class="n">pen_tip_1</span><span class="p">,</span> <span class="n">obj</span><span class="p">}},</span>
    <span class="p">{</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">SY_stable</span><span class="p">,</span> <span class="p">{</span><span class="n">pen_tip_0</span><span class="p">,</span> <span class="n">obj</span><span class="p">}},</span>
    <span class="p">{</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">SY_stable</span><span class="p">,</span> <span class="p">{</span><span class="n">pen_tip_1</span><span class="p">,</span> <span class="n">obj</span><span class="p">}},</span>
    <span class="p">{</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">SY_poseEq</span><span class="p">,</span> <span class="p">{</span><span class="n">obj</span><span class="p">,</span> <span class="n">goal</span><span class="p">}},</span>
<span class="p">};</span>
<span class="n">komo</span><span class="p">.</span><span class="n">setSkeleton</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="c1">// komo.addObjective({1.}, FS_vectorZ, {STRING(robots[0] &lt;&lt; "pen")}, OT_sos, {1e1}, {0., 0., -1.});</span>
<span class="n">komo</span><span class="p">.</span><span class="n">addObjective</span><span class="p">({</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">},</span> <span class="n">FS_distance</span><span class="p">,</span> <span class="p">{</span><span class="n">obj</span><span class="p">,</span> <span class="n">STRING</span><span class="p">(</span><span class="n">robots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"pen_tip"</span><span class="p">)},</span> <span class="n">OT_ineq</span><span class="p">,</span> <span class="p">{</span><span class="mf">1e1</span><span class="p">},{</span><span class="o">-</span><span class="mf">0.0</span><span class="p">});</span> 
<span class="n">komo</span><span class="p">.</span><span class="n">addObjective</span><span class="p">({</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">},</span> <span class="n">FS_distance</span><span class="p">,</span> <span class="p">{</span><span class="n">obj</span><span class="p">,</span> <span class="n">STRING</span><span class="p">(</span><span class="n">robots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"pen_tip"</span><span class="p">)},</span> <span class="n">OT_ineq</span><span class="p">,</span> <span class="p">{</span><span class="mf">1e1</span><span class="p">},{</span><span class="o">-</span><span class="mf">0.0</span><span class="p">});</span> 
</code></pre></div></div> <p><strong>Path planning</strong> is implemented using two methods: one based on the KOMO optimizer, and the other using bi-RRT.</p> <p>The <strong>KOMO optimizer</strong> solves the problem by using the provided initial and target positions, while setting velocity and acceleration constraints.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">OptOptions</span> <span class="n">options</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">stopIters</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// Set the maximum number of iterations.</span>
<span class="n">options</span><span class="p">.</span><span class="n">damping</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">stopLineSteps</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">komo</span><span class="p">.</span><span class="n">setConfiguration</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">q0</span><span class="p">);</span> <span class="c1">// By configuring KOMO for second-order optimization, it preserves position information from time step t-2 to t.</span>
<span class="n">komo</span><span class="p">.</span><span class="n">setConfiguration</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">q0</span><span class="p">);</span>
<span class="n">komo</span><span class="p">.</span><span class="n">setConfiguration</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q0</span><span class="p">);</span> 
<span class="n">komo</span><span class="p">.</span><span class="n">add_collision</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="mf">.001</span><span class="p">,</span> <span class="mf">1e1</span><span class="p">);</span>  <span class="c1">//set collision detection</span>
<span class="n">komo</span><span class="p">.</span><span class="n">addObjective</span><span class="p">({</span><span class="mi">1</span><span class="p">},</span> <span class="n">FS_qItself</span><span class="p">,</span> <span class="p">{},</span> <span class="n">OT_eq</span><span class="p">,</span> <span class="p">{</span><span class="mf">1e2</span><span class="p">},</span> <span class="n">q1</span><span class="p">);</span> <span class="c1">// set goal position q1</span>
<span class="n">komo</span><span class="p">.</span><span class="n">addObjective</span><span class="p">({</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">},</span> <span class="n">FS_qItself</span><span class="p">,</span> <span class="p">{},</span> <span class="n">OT_eq</span><span class="p">,</span> <span class="p">{</span><span class="mf">1e1</span><span class="p">},</span> <span class="p">{},</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// speed slow at end</span>
<span class="n">komo</span><span class="p">.</span><span class="n">addObjective</span><span class="p">({</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">},</span> <span class="n">FS_qItself</span><span class="p">,</span> <span class="p">{},</span> <span class="n">OT_eq</span><span class="p">,</span> <span class="p">{</span><span class="mf">1e1</span><span class="p">},</span> <span class="p">{},</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// acceleration slow at end</span>

<span class="n">komo</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>
<span class="c1">// get the path from KOMO</span>
<span class="n">arr</span> <span class="nf">path</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">N</span><span class="p">,</span> <span class="n">q0</span><span class="p">.</span><span class="n">N</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ts</span><span class="p">.</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
<span class="n">path</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">komo</span><span class="p">.</span><span class="n">getPath_q</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
<span class="p">};</span>

</code></pre></div></div> <p>The RRT path planner generates the path based on the initial and target positions provided by the KOMO optimizer.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TaskPart</span> <span class="n">rrt_path</span> <span class="o">=</span> <span class="n">plan_in_animation_rrt</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">time_lb</span><span class="p">,</span> <span class="n">prefix</span><span class="p">);</span> <span class="c1">// q0 is start configuration of joints, qi is goal configuration of joints</span>
</code></pre></div></div> <p>By using these two planners, a robot-arm’s movement path can be obtained in a straightforward and efficient manner.</p> <p>However, because the simulation framework defines object connections based on a tree structure where each node can only have one parent and one child, this restricts each object to being linked to only one end-effector at a time. For example, place the object on the table,</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">to</span> <span class="o">=</span> <span class="n">CPlanner</span><span class="p">[</span><span class="n">obj</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">from</span> <span class="o">=</span> <span class="n">CPlanner</span><span class="p">[</span><span class="s">"table_base"</span><span class="p">];</span>
<span class="n">to</span><span class="o">-&gt;</span><span class="n">unLink</span><span class="p">();</span>
<span class="n">to</span><span class="o">-&gt;</span><span class="n">linkFrom</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div></div> <p>Therefore, our solution is to use the target positions generated by the KOMO optimizer to determine the relative positions of the two robotic arms, and let second arm perform as pseudo-grasp.</p> \[\begin{aligned} ^{w}P = ^{w}r_{r1} + ^{w}R_{r1}\ ^{r1}P \end{aligned}\] <p>Let \(^{r1}P\) represent the relative displacement between two end effectors. By obtaining the coordinates \(^{w}r_{r1}\) and rotation matrix \(^{w}R_{r1}\) of the first end effector, we can determine the coordinates of the second end effector \(^{w}P\).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/transformation-480.webp 480w,/assets/img/transformation-800.webp 800w,/assets/img/transformation-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/transformation.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span> <span class="c1">// get the grasp position of robot 1</span>
    <span class="n">to</span><span class="o">-&gt;</span><span class="n">unLink</span><span class="p">();</span>
    <span class="n">to</span><span class="o">-&gt;</span><span class="n">linkFrom</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="n">r0_b</span> <span class="o">=</span>  <span class="n">CPlanner</span><span class="p">[</span><span class="n">pen_tip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">();</span>
    <span class="n">rotationmantix</span> <span class="o">=</span> <span class="n">CPlanner</span><span class="p">[</span><span class="n">pen_tip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getRotationMatrix</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span> <span class="c1">// get the grasp position of robot 2</span>
    <span class="n">r0_1</span> <span class="o">=</span> <span class="n">get_r_0_1</span><span class="p">(</span><span class="n">r0_b</span><span class="p">,</span><span class="n">rotationmantix</span><span class="p">,</span> <span class="n">CPlanner</span><span class="p">[</span><span class="n">pen_tip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">());</span> <span class="c1">// obtain the relative positions</span>
    <span class="p">}</span>

</code></pre></div></div> <p>Once the relative positions of the two end-effectors are determined, we can calculate the position of the second end-effector based on the path of the first one. Then, by using KOMO to compute the inverse kinematics, we obtain the angles for each joint.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint</span> <span class="n">size_of_path</span> <span class="o">=</span>  <span class="n">paths</span><span class="p">[</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">].</span><span class="n">back</span><span class="p">().</span><span class="n">path</span><span class="p">.</span><span class="n">N</span> <span class="o">/</span><span class="mi">7</span><span class="p">;</span>   <span class="c1">// het the size of path from first robot</span>
<span class="n">arr</span> <span class="n">t_a1</span><span class="p">;</span>
<span class="n">arr</span> <span class="nf">path_a1</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span><span class="n">paths</span><span class="p">[</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">].</span><span class="n">back</span><span class="p">().</span><span class="n">path</span><span class="p">.</span><span class="n">d1</span><span class="p">);</span>   <span class="c1">// define the path for second robot</span>
<span class="n">CPlanner</span><span class="p">.</span><span class="n">setJointState</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">robot</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
<span class="k">for</span><span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size_of_path</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">r0b</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">][</span><span class="mi">1</span><span class="p">].</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">].</span><span class="n">back</span><span class="p">().</span><span class="n">t</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">CTest</span><span class="p">.</span><span class="n">setJointState</span><span class="p">(</span><span class="n">r0b</span><span class="p">);</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">pen_tip</span> <span class="o">=</span>  <span class="n">STRING</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">"pen_tip"</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">_r0_b</span> <span class="o">=</span> <span class="n">CTest</span><span class="p">[</span><span class="n">pen_tip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">rotationmatrix</span> <span class="o">=</span> <span class="n">CTest</span><span class="p">[</span><span class="n">pen_tip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getRotationMatrix</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">_goal_pose</span> <span class="o">=</span> <span class="n">get_trans_position</span><span class="p">(</span><span class="n">_r0_b</span><span class="p">,</span><span class="n">rotationmatrix</span><span class="p">,</span><span class="n">r0_1</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">goal_pose_</span><span class="o">=</span> <span class="n">get_position</span><span class="p">(</span><span class="n">CPlanner</span><span class="p">,</span><span class="n">robot</span><span class="p">,</span><span class="n">_goal_pose</span><span class="p">);</span>     <span class="c1">// use KOMO to compute the inverse kinematics</span>
    <span class="n">CPlanner</span><span class="p">.</span><span class="n">setJointState</span><span class="p">(</span><span class="n">goal_pose_</span><span class="p">);</span>
    <span class="n">t_a1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="n">path_a1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">goal_pose_</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">TaskPart</span> <span class="nf">path_</span><span class="p">(</span><span class="n">t_a1</span><span class="p">,</span><span class="n">path_a1</span><span class="p">);</span>
<span class="n">path_</span><span class="p">.</span><span class="n">has_solution</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
</code></pre></div></div> <h2 id="result">Result</h2> <p>In our tests, we found that when both RRT and KOMO can find a path, the path generated by KOMO is usually shorter,</p> <table> <thead> <tr> <th>Method</th> <th>path1</th> <th>path2</th> <th>path3</th> <th>path4</th> </tr> </thead> <tbody> <tr> <td>KOMO</td> <td>30</td> <td>111</td> <td>153</td> <td>182</td> </tr> <tr> <td>RRT</td> <td>31</td> <td>136</td> <td>171</td> <td>185</td> </tr> </tbody> </table> <p>In the animation below, the left side shows the path generated by KOMO, while the right side shows the path generated by RRT. We can observe that the path generated by KOMO is faster than the one generated by RRT.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <video src="/assets/video/blog1.mp4" class="img-fluid rounded z-depth-1" width="auto" height="auto" autoplay="" controls=""></video> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <video src="/assets/video/blog2.mp4" class="img-fluid rounded z-depth-1" width="auto" height="auto" controls=""></video> </figure> </div> </div> <p>In addition, we also tested the obstacle avoidance functionality of this path planner and found that it effectively avoids obstacles during path planning. Below are some of our simulation test videos.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <video src="/assets/video/stacking_co_3.mp4" class="img-fluid rounded z-depth-1" width="auto" height="auto" autoplay="" controls=""></video> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <video src="/assets/video/cooperation_4.mp4" class="img-fluid rounded z-depth-1" width="auto" height="auto" controls=""></video> </figure> </div> </div> <h2 id="conclusion">Conclusion</h2> <p>The KOMO solver can efficiently compute inverse solutions and plan paths, but there are still some scenarios where it fails to find a valid solution. Additionally, while our method allows both robotic arms to grasp an object simultaneously, the second arm is performing a pseudo-grasp, which causes rotation between the end-effector and the object during movement. This aspect can be improved in future work.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Haolei Tong. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>