<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Multi-Robot Pick and Place | Haolei's Pit </title> <meta name="author" content="Haolei Tong"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://thomasston.github.io/blog/2024/irobmanlab_blog/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Haolei's Pit </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Multi-Robot Pick and Place</h1> <p class="post-meta"> Created in September 05, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/lab"> <i class="fa-solid fa-hashtag fa-sm"></i> lab</a>   <a href="/blog/tag/project"> <i class="fa-solid fa-hashtag fa-sm"></i> project</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>For this project, we need to implement the simultaneous manipulation of two objects using two Franka robotic arms in a simulation environment. The project utilizes the KOMO optimizer and bi-RRT for planning the motion paths of the robotic arms.</p> <p><strong>k-order Markov Optimization</strong> is a method used in decision-making processes where the current decision depends not just on the immediate previous state (as in a first-order Markov process) but on a sequence of previous states, up to k steps in the past:</p> \[\min_{x_{0:T}} \sum_{t=0}^{T} f_t(x_{t-k:t})^\top f_t(x_{t-k:t}) + \sum_{t,t'} k(t,t') x_t^\top x_{t'}\] \[\text{s.t.} \quad \forall t : g_t(x_{t-k:t}) \leq 0, \quad h_t(x_{t-k:t}) = 0.\] <p>where \(x_{t-k:t} = (x_{t-k},..., x_{t-1}, x_{t})\) are \(k+1\) tuples of consecutive states. And the the term \(k(t,t^{'})\) is an optional kernel measuring the desired correlation between time steps \(t\) and \(t^{'}\), which we explored but in practice hardly used.</p> <p>To compute the inverse kinematics of a robotic arm, we typically need to define the following parameters:</p> \[\begin{aligned} q &amp;\in \mathbb{R}^n &amp;\text{vector of joint angles (robot configuration)} \\ \dot{q} &amp;\in \mathbb{R}^n &amp;\text{vector of joint angular velocities} \\ \phi : q &amp;\mapsto y \in \mathbb{R}^d &amp;\text{feature (or forward kinematic)} \text{e.g. position} \in \mathbb{R}^3 \text{ or vector} \in \mathbb{R}^3 \\ J(q) &amp;= \frac{\partial \phi}{\partial q} \in \mathbb{R}^{d \times n} &amp;\text{Jacobian} \end{aligned}\] <p>To apply KOMO (K-order Markov Optimization) to inverse kinematics with \(k=2\):</p> \[\begin{aligned} J_{\text{pos}} &amp;= \sum_{t=1}^{T} \| \mathbf{y}_t^{\text{desired}} - \mathbf{y}_t(\mathbf{q}_t) \|^2 &amp;\text{Error of the end effector} \\ J_{\text{smooth}} &amp;= \sum_{t=3}^{T} \left( \lambda_1 \| \theta_t - \theta_{t-1} \|^2 + \lambda_2 \| \theta_t - 2\theta_{t-1} + \theta_{t-2} \|^2 \right) &amp;\text{Smoothness Constraint}\\ \end{aligned}\] <p>Specifically:</p> <p>\(\lambda_{1}\) controls the first-order smoothness (to prevent excessive changes in joint angles between consecutive time steps).</p> <p>\(\lambda_{2}\) controls second-order smoothness (to avoid abrupt changes in acceleration or angular velocity).</p> <p>\(\theta_{t} - 2\theta_{t-1} + \theta_{t-2}\) approximately describes the change in acceleration of the joint angles.</p> <p>The final total cost function is:</p> \[\begin{aligned} J &amp;= J_{pos} + J_{smooth} + \text{other constraint terms} \end{aligned}\] <p>We need to minimize this objective function \(J\), .i.e,</p> \[\min_{\theta_{t}, \theta_{t-1}, \theta_{t-2}} J\] <p><strong>Bi-directional Rapidly-exploring Random Tree (Bi-RRT)</strong> is an enhanced version of the Rapidly-exploring Random Tree (RRT) algorithm. Unlike the standard RRT, which grows a single tree from the start to explore the space, Bi-RRT grows two trees simultaneously,i.e., One tree starts from the initial position of the robot, the other tree starts from the goal position. Both trees expand alternately by randomly sampling points in the space and attempting to extend the trees towards those points. Once the two trees are connected, a valid path is formed that goes from the start, through the nodes of the first tree, to the connecting point, and then through the nodes of the second tree to the goal.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/rrt_img-480.webp 480w,/assets/img/rrt_img-800.webp 800w,/assets/img/rrt_img-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/rrt_img.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><strong>Setting up the simulation environment:</strong></p> <p>Typically, we need to configure the initial position of the objects to be grasped, the target positions, and also the placement of the robotic arms.</p> <p>For the <strong>objects</strong> to be grasped, we need to define the coordinates and the rotational angles using quaternions. For the initial position, “contact” should be set to 1 for collision detection, while for the target position, it should be set to 0.</p> <pre><code class="language-PHP">goal1 (bin1){ joint:rigid type:ssBox, size:[0.1 0.1 0.1 .01], contact:0 Q:&lt;[  0, 0.0, 0.13, 1., 0., .0, 0]&gt; color:[0.4, 1, 1, 0.2]}
goal2 (bin1){ joint:rigid type:ssBox, size:[0.1 0.1 0.1 .01], contact:0 Q:&lt;[  0, 0.0, 0.23, 1., 0., .0, 0]&gt; color:[0.4, 1, 1, 0.2]}
goal3 (bin2){ joint:rigid type:ssBox, size:[0.20 0.20 0.1 .01], contact:0 Q:&lt;[  0, 0.05, 0.03, 1., 0., .0, 0]&gt; color:[0.4, 1, 1, 0.2]}

obj3 (bin1){ joint:rigid type:ssBox, size:[0.20 0.20 0.1 .01], contact:1 Q:&lt;[ 0, -0., 0.03, 1, 0, .0, 0]&gt; color:[0.4, 1, 1, 1]}
obj2 (bin2){ joint:rigid type:ssBox, size:[0.1 0.1 0.1 .01], contact:1 Q:&lt;[  -0., -0.15, 0.03, 1, 0, .0, 0]&gt; color:[0.4, 1, 1, 1]}
obj1 (bin2){ joint:rigid type:ssBox, size:[0.1 0.1 0.1 .01], contact:1 Q:&lt;[  -0., -0.01, 0.03, 1, 0, .0, 0]&gt; color:[0.4, 1, 1, 1]}
</code></pre> <p>For the robotic arms, we need to configure their placement positions as well as the initial position of each joint. Typically, the distance between the two arms should be set large enough to avoid joint collisions when grasping the same object.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">const</span> <span class="n">arrA</span> <span class="n">basePos</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.00</span><span class="p">},</span>
    <span class="p">{</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">}</span>
<span class="p">};</span>

<span class="k">const</span> <span class="n">arrA</span> <span class="n">baseQuat</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
    <span class="p">{</span><span class="mf">0.924</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.383</span><span class="p">},</span>
    <span class="p">{</span><span class="o">-</span><span class="mf">0.383</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.924</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">addFile</span><span class="p">(</span><span class="s">"./in/franka.g"</span><span class="p">);</span>
    <span class="n">C</span><span class="p">.</span><span class="n">reconfigureRoot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">linkFrom</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="s">"table"</span><span class="p">]);</span>
    <span class="k">const</span> <span class="n">rai</span><span class="o">::</span><span class="n">String</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">STRING</span><span class="p">(</span><span class="sc">'a'</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'_'</span><span class="p">);</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">prefixSubtree</span><span class="p">(</span><span class="n">prefix</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">rai</span><span class="o">::</span><span class="n">String</span> <span class="n">agentBase</span> <span class="o">=</span> <span class="n">STRING</span><span class="p">(</span><span class="n">prefix</span> <span class="o">&lt;&lt;</span> <span class="s">"base"</span><span class="p">);</span>
    <span class="n">C</span><span class="p">[</span><span class="n">agentBase</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setRelativePosition</span><span class="p">(</span><span class="n">basePos</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="n">C</span><span class="p">[</span><span class="n">agentBase</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setQuaternion</span><span class="p">(</span><span class="n">baseQuat</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="n">setActive</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">prefix</span><span class="p">.</span><span class="n">p</span><span class="p">));</span>
    <span class="n">arr</span> <span class="n">state</span> <span class="o">=</span> <span class="n">C</span><span class="p">.</span><span class="n">getJointState</span><span class="p">();</span>
    <span class="n">C</span><span class="p">.</span><span class="n">setJointState</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>In the <strong>task plan</strong>, since this project involves two robotic arms completing a task simultaneously, there is no need to account for the Traveling Salesman Problem. The tasks can simply be assigned in sequence, i.e., {task_{1}(robot_{1}, robot_{2}), task_{2}(robot_{1}, robot_{2})}.</p> <p>Here, a task represents the movement of a robotic arm from position A to position B. For example, moving the arm from the initial position to the position where it can grasp an object constitutes a task. The content of the task is determined by the joint configurations that correspond to the target positions of the robot’s end effector.</p> <p>In this project, we use the <strong>KOMO</strong> optimizer to solve the inverse kinematics:</p> <p>We can configure the optimizer using the skeleton framework: {1., 1., SY_touch, {pen_tip_0, obj}}: <strong>‘1.’</strong> represents the timestep, <strong>‘SY_touch’</strong> indicates contact with the target, can be replaced with other types of constraints, such as <strong>SY_stable</strong>, which indicates being stationary relative to the target, <strong>‘pen_tip’</strong> represents the robot’s end-effector, <strong>‘obj’</strong> represents the target.</p> <p>Additionally, we can use <strong>addObjective</strong> to add extra constraints, such as ensuring the distance between the end-effector and the object is zero, or enforcing that the end-effector remains perpendicular to the object’s surface.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">Skeleton</span> <span class="n">S</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">SY_touch</span><span class="p">,</span> <span class="p">{</span><span class="n">pen_tip_0</span><span class="p">,</span> <span class="n">obj</span><span class="p">}},</span>
    <span class="p">{</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">SY_touch</span><span class="p">,</span> <span class="p">{</span><span class="n">pen_tip_1</span><span class="p">,</span> <span class="n">obj</span><span class="p">}},</span>
    <span class="p">{</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">SY_stable</span><span class="p">,</span> <span class="p">{</span><span class="n">pen_tip_0</span><span class="p">,</span> <span class="n">obj</span><span class="p">}},</span>
    <span class="p">{</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">SY_stable</span><span class="p">,</span> <span class="p">{</span><span class="n">pen_tip_1</span><span class="p">,</span> <span class="n">obj</span><span class="p">}},</span>
    <span class="p">{</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">SY_poseEq</span><span class="p">,</span> <span class="p">{</span><span class="n">obj</span><span class="p">,</span> <span class="n">goal</span><span class="p">}},</span>
<span class="p">};</span>
<span class="n">komo</span><span class="p">.</span><span class="n">setSkeleton</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="c1">// komo.addObjective({1.}, FS_vectorZ, {STRING(robots[0] &lt;&lt; "pen")}, OT_sos, {1e1}, {0., 0., -1.});</span>
<span class="n">komo</span><span class="p">.</span><span class="n">addObjective</span><span class="p">({</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">},</span> <span class="n">FS_distance</span><span class="p">,</span> <span class="p">{</span><span class="n">obj</span><span class="p">,</span> <span class="n">STRING</span><span class="p">(</span><span class="n">robots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"pen_tip"</span><span class="p">)},</span> <span class="n">OT_ineq</span><span class="p">,</span> <span class="p">{</span><span class="mf">1e1</span><span class="p">},{</span><span class="o">-</span><span class="mf">0.0</span><span class="p">});</span> 
<span class="n">komo</span><span class="p">.</span><span class="n">addObjective</span><span class="p">({</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">},</span> <span class="n">FS_distance</span><span class="p">,</span> <span class="p">{</span><span class="n">obj</span><span class="p">,</span> <span class="n">STRING</span><span class="p">(</span><span class="n">robots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"pen_tip"</span><span class="p">)},</span> <span class="n">OT_ineq</span><span class="p">,</span> <span class="p">{</span><span class="mf">1e1</span><span class="p">},{</span><span class="o">-</span><span class="mf">0.0</span><span class="p">});</span> 
</code></pre></div></div> <p><strong>Path planning</strong> is implemented using two methods: one based on the KOMO optimizer, and the other using bi-RRT.</p> <p>The <strong>KOMO optimizer</strong> solves the problem by using the provided initial and target positions, while setting velocity and acceleration constraints.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">OptOptions</span> <span class="n">options</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">stopIters</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// Set the maximum number of iterations.</span>
<span class="n">options</span><span class="p">.</span><span class="n">damping</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">stopLineSteps</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">komo</span><span class="p">.</span><span class="n">setConfiguration</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">q0</span><span class="p">);</span> <span class="c1">// By configuring KOMO for second-order optimization, it preserves position information from time step t-2 to t.</span>
<span class="n">komo</span><span class="p">.</span><span class="n">setConfiguration</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">q0</span><span class="p">);</span>
<span class="n">komo</span><span class="p">.</span><span class="n">setConfiguration</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q0</span><span class="p">);</span> 
<span class="n">komo</span><span class="p">.</span><span class="n">add_collision</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="mf">.001</span><span class="p">,</span> <span class="mf">1e1</span><span class="p">);</span>  <span class="c1">//set collision detection</span>
<span class="n">komo</span><span class="p">.</span><span class="n">addObjective</span><span class="p">({</span><span class="mi">1</span><span class="p">},</span> <span class="n">FS_qItself</span><span class="p">,</span> <span class="p">{},</span> <span class="n">OT_eq</span><span class="p">,</span> <span class="p">{</span><span class="mf">1e2</span><span class="p">},</span> <span class="n">q1</span><span class="p">);</span> <span class="c1">// set goal position q1</span>
<span class="n">komo</span><span class="p">.</span><span class="n">addObjective</span><span class="p">({</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">},</span> <span class="n">FS_qItself</span><span class="p">,</span> <span class="p">{},</span> <span class="n">OT_eq</span><span class="p">,</span> <span class="p">{</span><span class="mf">1e1</span><span class="p">},</span> <span class="p">{},</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// speed slow at end</span>
<span class="n">komo</span><span class="p">.</span><span class="n">addObjective</span><span class="p">({</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">},</span> <span class="n">FS_qItself</span><span class="p">,</span> <span class="p">{},</span> <span class="n">OT_eq</span><span class="p">,</span> <span class="p">{</span><span class="mf">1e1</span><span class="p">},</span> <span class="p">{},</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// acceleration slow at end</span>

<span class="n">komo</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>
<span class="c1">// get the path from KOMO</span>
<span class="n">arr</span> <span class="nf">path</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">N</span><span class="p">,</span> <span class="n">q0</span><span class="p">.</span><span class="n">N</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ts</span><span class="p">.</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
<span class="n">path</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">komo</span><span class="p">.</span><span class="n">getPath_q</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
<span class="p">};</span>

</code></pre></div></div> <p>The RRT path planner generates the path based on the initial and target positions provided by the KOMO optimizer.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TaskPart</span> <span class="n">rrt_path</span> <span class="o">=</span> <span class="n">plan_in_animation_rrt</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">time_lb</span><span class="p">,</span> <span class="n">prefix</span><span class="p">);</span> <span class="c1">// q0 is start configuration of joints, qi is goal configuration of joints</span>
</code></pre></div></div> <p>By using these two planners, a robot-arm’s movement path can be obtained in a straightforward and efficient manner.</p> <p>However, because the simulation framework defines object connections based on a tree structure where each node can only have one parent and one child, this restricts each object to being linked to only one end-effector at a time. For example, place the object on the table,</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">to</span> <span class="o">=</span> <span class="n">CPlanner</span><span class="p">[</span><span class="n">obj</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">from</span> <span class="o">=</span> <span class="n">CPlanner</span><span class="p">[</span><span class="s">"table_base"</span><span class="p">];</span>
<span class="n">to</span><span class="o">-&gt;</span><span class="n">unLink</span><span class="p">();</span>
<span class="n">to</span><span class="o">-&gt;</span><span class="n">linkFrom</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div></div> <p>Therefore, our solution is to use the target positions generated by the KOMO optimizer to determine the relative positions of the two robotic arms,</p> <p><strong>picture</strong></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span> <span class="c1">// get the grasp position of robot 1</span>
    <span class="n">to</span><span class="o">-&gt;</span><span class="n">unLink</span><span class="p">();</span>
    <span class="n">to</span><span class="o">-&gt;</span><span class="n">linkFrom</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="n">r0_b</span> <span class="o">=</span>  <span class="n">CPlanner</span><span class="p">[</span><span class="n">pen_tip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">();</span>
    <span class="n">rotationmantix</span> <span class="o">=</span> <span class="n">CPlanner</span><span class="p">[</span><span class="n">pen_tip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getRotationMatrix</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span> <span class="c1">// get the grasp position of robot 2</span>
    <span class="n">r0_1</span> <span class="o">=</span> <span class="n">get_r_0_1</span><span class="p">(</span><span class="n">r0_b</span><span class="p">,</span><span class="n">rotationmantix</span><span class="p">,</span> <span class="n">CPlanner</span><span class="p">[</span><span class="n">pen_tip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">());</span> <span class="c1">// obtain the relative positions</span>
    <span class="p">}</span>

</code></pre></div></div> <p>Once the relative positions of the two end-effectors are determined, we can calculate the position of the second end-effector based on the path of the first one. Then, by using KOMO to compute the inverse kinematics, we obtain the angles for each joint.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint</span> <span class="n">size_of_path</span> <span class="o">=</span>  <span class="n">paths</span><span class="p">[</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">].</span><span class="n">back</span><span class="p">().</span><span class="n">path</span><span class="p">.</span><span class="n">N</span> <span class="o">/</span><span class="mi">7</span><span class="p">;</span>   <span class="c1">// het the size of path from first robot</span>
<span class="n">arr</span> <span class="n">t_a1</span><span class="p">;</span>
<span class="n">arr</span> <span class="nf">path_a1</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span><span class="n">paths</span><span class="p">[</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">].</span><span class="n">back</span><span class="p">().</span><span class="n">path</span><span class="p">.</span><span class="n">d1</span><span class="p">);</span>   <span class="c1">// define the path for second robot</span>
<span class="n">CPlanner</span><span class="p">.</span><span class="n">setJointState</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">robot</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
<span class="k">for</span><span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size_of_path</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">r0b</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">][</span><span class="mi">1</span><span class="p">].</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">].</span><span class="n">back</span><span class="p">().</span><span class="n">t</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">CTest</span><span class="p">.</span><span class="n">setJointState</span><span class="p">(</span><span class="n">r0b</span><span class="p">);</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">pen_tip</span> <span class="o">=</span>  <span class="n">STRING</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">"pen_tip"</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">_r0_b</span> <span class="o">=</span> <span class="n">CTest</span><span class="p">[</span><span class="n">pen_tip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">rotationmatrix</span> <span class="o">=</span> <span class="n">CTest</span><span class="p">[</span><span class="n">pen_tip</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getRotationMatrix</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">_goal_pose</span> <span class="o">=</span> <span class="n">get_trans_position</span><span class="p">(</span><span class="n">_r0_b</span><span class="p">,</span><span class="n">rotationmatrix</span><span class="p">,</span><span class="n">r0_1</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">goal_pose_</span><span class="o">=</span> <span class="n">get_position</span><span class="p">(</span><span class="n">CPlanner</span><span class="p">,</span><span class="n">robot</span><span class="p">,</span><span class="n">_goal_pose</span><span class="p">);</span>     <span class="c1">// use KOMO to compute the inverse kinematics</span>
    <span class="n">CPlanner</span><span class="p">.</span><span class="n">setJointState</span><span class="p">(</span><span class="n">goal_pose_</span><span class="p">);</span>
    <span class="n">t_a1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="n">path_a1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">goal_pose_</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">TaskPart</span> <span class="nf">path_</span><span class="p">(</span><span class="n">t_a1</span><span class="p">,</span><span class="n">path_a1</span><span class="p">);</span>
<span class="n">path_</span><span class="p">.</span><span class="n">has_solution</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
</code></pre></div></div> <h2 id="result">Result</h2> <p>In our tests, we found that when both RRT and KOMO can find a path, the path generated by KOMO is usually shorter,</p> <table> <thead> <tr> <th>Method</th> <th>path1</th> <th>path2</th> <th>path3</th> <th>path4</th> </tr> </thead> <tbody> <tr> <td>KOMO</td> <td>30</td> <td>111</td> <td>153</td> <td>182</td> </tr> <tr> <td>RRT</td> <td>31</td> <td>136</td> <td>171</td> <td>185</td> </tr> </tbody> </table> <p>From the animation below, we can also see that the path generated by KOMO is faster than that of RRT.</p> <table> <thead> <tr> <th>KOMO</th> <th>RRT</th> </tr> </thead> <tbody> <tr> <td><img src="/home/haolei/thomasston.github.io/assets/video/blog1.gif" alt="演示动画"></td> <td><img src="assets/video/blog2.gif" alt="005" style="zoom: 70%;"></td> </tr> </tbody> </table> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Haolei Tong. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>